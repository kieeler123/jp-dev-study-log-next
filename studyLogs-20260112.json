[{"id":1766062774108,"category":"coding","title":"function vs const 함수작성차이","content":"1️⃣ function 선언문 (Function Declaration)\nfunction add(a, b) {\n  return a + b;\n}\n\n특징\n\n✅ 완전한 호이스팅\n\n파일 맨 위로 끌어올려진 것처럼 동작\n\n선언 전에 호출 가능\n\nconsole.log(add(2, 3)); // 5\n\nfunction add(a, b) {\n  return a + b;\n}\n\n스코프\n\n블록 스코프 아님 (엄밀히 말하면 함수 스코프)\n\nif / for 안에서 선언해도 스코프가 헷갈릴 수 있음\n\nif (true) {\n  function foo() {}\n}\n\nfoo(); // 실행되는 경우가 있음 (환경 의존)\n\n\n👉 이게 싫어서 현대 JS에서는 잘 안 쓰려는 경향이 있어.\n\n2️⃣ const + 함수 표현식 (Function Expression)\nconst add = function (a, b) {\n  return a + b;\n};\n\n\n또는 (실무에서 더 흔함)\n\nconst add = (a, b) => a + b;\n\n특징\n\n❌ 호이스팅 안 됨 (정확히는 TDZ)\n\n선언 전에 호출하면 에러\n\nadd(2, 3); // ❌ ReferenceError\n\nconst add = (a, b) => a + b;\n\n스코프\n\n✅ 블록 스코프\n\n예측 가능\n\nif / for 안에서 안전\n\nif (true) {\n  const foo = () => {};\n}\n\nfoo(); // ❌ ReferenceError\n\n\n👉 의도한 범위에서만 쓰이게 강제할 수 있음\n\n3️⃣ 호이스팅 차이 정확한 설명 (중요)\n방식\t실제 호이스팅\nfunction foo(){}\t함수 전체가 메모리에 올라감\nconst foo = () => {}\t변수만 호이스팅 + TDZ\nconsole.log(foo); // ❌ ReferenceError\n\nconst foo = () => {};\n\n\nconst/let은 호이스팅은 되지만 접근이 막혀 있음 (TDZ)\n\n4️⃣ 실무에서 어떻게 쓰느냐 (이게 핵심)\n🔹 function 선언문 쓰는 경우\n\n유틸 함수\n\n파일 전체에서 공통으로 쓰는 함수\n\n의도적으로 “어디서든 쓸 수 있음”을 표현할 때\n\nfunction formatDate(date) {\n  ...\n}\n\n🔹 const 함수 쓰는 경우 (요즘 기본값)\n\n컴포넌트 내부 로직\n\n콜백\n\n클로저\n\nReact / TS 환경\n\nconst handleClick = () => {\n  ...\n};\n\n\n👉 요즘은 이게 사실상 표준\n\n5️⃣ React / TypeScript 기준 정리\n\n네가 React + TS 쓰고 있으니까 현실 기준으로 말하면:\n\n✅ 추천 패턴\nconst fetchData = async (): Promise<void> => {\n  ...\n};\n\n❌ 피하는 패턴\nfunction fetchData() {\n  ...\n}\n\n\n이유:\n\n스코프 명확\n\n리팩토링 쉬움\n\n테스트/의존성 추적 쉬움\n\n팀 컨벤션과 맞음\n\n6️⃣ 한 줄 요약 (외워도 됨)\n\nfunction = 옛날 방식, 전역 유틸\nconst 함수 = 현대 JS, 예측 가능한 코드","date":"2025-12-18T12:59:34.108Z"},{"id":1766316584892,"category":"coding","title":"React CDN 사용법","content":"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <script\n        crossorigin\n        src=\"https://unpkg.com/react@18/umd/react.development.js\"\n    ></script>\n    <script\n        crossorigin\n        src=\"https://unpkg.com/react-dom@18/umd/react-dom.development.js\"\n    ></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n</head>\n<body>\n    <div id=\"root\"></div>\n    <script type=\"text/babel\">\n        const App = () => {\n            const [todos,setTodos] = React.useState([]);\n            const [text,setText]=React.useState(\"\")\n\n            const onClick = () => {\n                setTodos([...todos,text])\n                setText(\"\")\n            };\n            return(\n                <>\n                    <h1>todoList</h1>\n                    <input value={text} onChange={(e)=>setText(e.target.value)} />\n                    <button onClick={onClick}>click</button>\n                    <ul>{todos.map((todo,i)=>(\n                        <li key={i}>{todo}</li>\n                    ))}</ul>\n                </>\n            )\n        };\n\n        const root = ReactDOM.createRoot(document.querySelector(\"#root\"));\n        root.render(<App />);\n    </script>\n</body>\n</html>\n\n이렇게해서 cdn방식으로 리액트를 사용해보았다 크롬에 react를검색하면 cdn방식사용법을 쉽게 알수있지만 우선은 head부분에 \n<script crossorigin src=\"https://unpkg.com/react@18/umd/react.development.js\"></script>\n<script crossorigin src=\"https://unpkg.com/react-dom@18/umd/react-dom.development.js\"></script>\n<script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n\n이 세줄을 입력해야한다 위 두줄은 기본적인 react 사용을 위한것들이고 마지막줄은 babel로사용하는것이다 babel설정을 안해줬더니 syntax에러가떴다 cursor에게 물어보니 jsx로직을 브라우저가 읽을수없기때문에 syntax에러가뜨는거라고하더라 babel설정해줬더니 바로 동작하더라 body 바로밑에 <div id=\"root\"></div>부분은 리액트 사용해보면알겠지만 모든 코드가 이안에작성된다 마지막부분에 const root = ReactDOM.createRoot(document.querySelector(\"#root\"));\n        root.render(<App />); 이부분도 꼭 써줘야 동작한다","date":"2025-12-21T11:29:44.892Z"},{"id":1766323059958,"category":"japanese","title":"React에대한 간단한 이해","content":"일본 중소기업 “합격선”을 정확히 말하면\n💯 충분한 합격 설명 수준은 이 정도\n\nReact는 상태 기반으로 UI를 그린다\n\nuseState는 상태 변경을 트리거한다\n\nJSX는 Babel로 JS로 변환된다\n\n배열은 불변성을 지켜서 업데이트한다\n\n조건 렌더링으로 UI 상태를 나눈다\n\n👉 이걸 말로 설명 가능하면\n“React 이해하고 있음” 판정이 나와.\n\n❗ 여기서 더 깊은 내부 구현(파이버, 스케줄러 등)은\n중소기업 신입에게 전혀 요구되지 않음.","date":"2025-12-21T13:17:39.958Z"},{"id":1767068740968,"category":"japanese","title":"「仕組み（しくみ）」","content":"「仕組み（しくみ）」とは、物事が成り立つための基本的な構造、原理、または手順を指し、機械の動作原理から組織の運営方法、自然現象の法則まで幅広く使われ、「システム」「メカニズム」「構造」「計画」といった意味合いで、「誰がやっても同じ結果を出せるように標準化・設計された方法」（仕組み化）を指すビジネス用語としても重要です。 \n「仕組み」の主な意味と使われ方\n構造・メカニズム: 機械のギアの噛み合わせや、生物の体の構造など、部品が連動して機能する原理。\nシステム・プロセス: 組織が目標を達成するための運営方法、業務の流れ、ルールなど。\n工夫・計画: 物事をうまく運ぶために、意図的に作り上げられた計画や仕掛け（例：小説の伏線）。 \nビジネスにおける「仕組み化」\n目的: 特定の人に依存せず（属人化を防ぎ）、誰でも、いつ、どこでやっても同じ品質と成果が出せる状態を作ること。\n具体例: 詳細なマニュアル作成、業務の自動化、SaaSツールの導入など。\nメリット: ムダの削減、品質の安定、技術継承の促進、生産性向上など。 \n類語・言い換え\nシステム、メカニズム、構造、プロセス、フレームワーク、機構、体系、設計。 \n例\n「時計の仕組みがわからない」→ 内部の構造や動作原理。\n「会社の仕組みを変える」→ 業務プロセスや組織運営の方法。\n「営業の仕組み化」→ 属人的な営業手法をマニュアル化し、誰でもできるようにする。 \n「仕組み」を理解することで、物事の本質を把握し、より効率的・効果的な改善（仕組み化）が可能になります。","date":"2025-12-30T04:25:40.968Z"},{"id":1767685707681,"category":"coding","title":"📘 Vanilla JS CRUD + Search/Filter 구현 기록 (자기 점검용)","content":"📘 Vanilla JS CRUD + Search/Filter 구현 기록 (자기 점검용)\n1. 이 코드는 무엇을 하는가 (전체 개요)\n\n이 코드는 바닐라 JavaScript로 CRUD + 검색 + 필터 기능을 구현한 간단한 리스트 앱이다.\nReact 없이 DOM을 직접 다루며, 상태(state), 파생 데이터, 렌더링, 이벤트 흐름을 명확히 분리하는 구조를 사용했다.\n\n목표는 기능 구현 자체보다도 데이터 흐름과 UI 갱신 구조를 이해하고 설명할 수 있는가에 있다.\n\n2. 전체 구조를 한 줄로 요약하면\n\nHTML은 구조만 제공하고,\n상태는 JS에서 관리하며,\n화면에 보여줄 데이터는 파생 계산으로 만들고,\nDOM 갱신은 render 함수 한 곳에서 처리한다.\n\n이 설명이 가능하면 구조 이해는 충분하다.\n\n3. DOM 접근 방식에 대한 이해\nconst $ = (s) => document.querySelector(s);\n\n\nDOM 요소 접근을 간단히 하기 위한 헬퍼 함수\n\njQuery 스타일을 흉내 낸 것일 뿐, 핵심 로직은 아님\n\n각 id는 HTML에 존재하는 UI 요소를 JS에서 제어하기 위한 연결 지점이다.\n\n여기서 중요한 건:\n\nHTML 구조와 JS 로직을 분리했다는 점\n\nJS는 HTML을 “조작”하는 역할만 맡는다\n\n4. 상태(state)에 대한 이해\nlet items = []; // source of truth\n\n\nitems는 이 앱의 유일한 데이터 원본\n\n화면에 보이는 내용은 항상 이 배열을 기준으로 만들어진다\n\nDOM에서 직접 데이터를 읽지 않는다\n\n👉 상태는 JS에, 화면은 상태의 결과물이라는 인식이 핵심이다.\n\n5. 검색 / 필터 로직의 위치와 역할\nconst visibleItems = () => { ... }\n\n\n이 함수는:\n\n현재 상태(items)\n\n현재 UI 상태(q.value, filter.value)\n\n를 바탕으로\n👉 “지금 화면에 보여줘야 할 데이터만 계산” 한다.\n\n중요한 점:\n\n이 함수는 DOM을 건드리지 않는다\n\n순수하게 “계산”만 담당한다\n\n즉,\n\n검색/필터는 렌더링 문제가 아니라 데이터 계산 문제라는 구분을 하고 있다.\n\n이 설명이 가능하면 충분하다.\n\n6. render 함수의 존재 이유\nconst render = () => { ... }\n\n\nDOM 갱신을 이 함수 한 곳에서만 처리\n\n상태가 바뀌면 항상 render()를 다시 호출\n\n이 구조의 의도는:\n\nDOM 조작이 여기저기 흩어지는 것을 방지\n\nReact의 “state 변경 → 자동 리렌더” 개념을 바닐라로 직접 구현한 것\n\n👉 왜 render를 따로 만들었는지 설명 가능하면 충분하다.\n\n7. escapeHtml 함수의 역할 이해\nconst escapeHtml = (s) => ...\n\n\n사용자 입력을 innerHTML로 출력하기 때문에\n\nHTML 태그가 실행되는 것을 막기 위한 최소한의 안전 처리\n\n중요한 건:\n\n왜 여기서 필요했는지\n\n출력 직전에만 사용한다는 점\n\n구현 세부를 외울 필요는 없다.\n\n8. CRUD 중 Create (추가) 로직\nform.addEventListener(\"submit\", ...)\n\n\n이 로직의 흐름은:\n\n사용자 입력을 받는다\n\n새로운 아이템 객체를 만든다\n\n상태(items)를 변경한다\n\nrender()를 호출해 화면을 갱신한다\n\n👉 이 흐름을 말로 설명할 수 있으면 충분하다.\n\n9. Search / Filter 이벤트 처리 방식\nq.addEventListener(\"input\", render);\nfilter.addEventListener(\"change\", render);\n\n\n검색어/필터가 바뀌면\n\n상태는 그대로 두고\n\n화면만 다시 계산해서 그린다\n\n즉,\n\n검색/필터는 상태 변경이 아니라 “보여주는 방식”의 변경이다.\n\n이 구분이 핵심이다.\n\n10. Update / Delete를 이벤트 위임으로 처리한 이유\nlist.addEventListener(\"click\", ...)\n\n\n리스트 아이템이 동적으로 생성되므로\n\n각 버튼마다 이벤트를 붙이지 않고\n\n부모 요소에서 이벤트를 한 번에 처리\n\n여기서:\n\ndataset.id는 HTML에 저장해 둔 식별자를 읽기 위한 수단\n\ngetAttribute/dataset의 내부 원리까지 설명할 필요는 없음\n\n👉 “왜 여기서 id가 필요했는지”만 설명 가능하면 충분하다.\n\n11. 이 수준이면 신입 기준으로 충분한가?\n✅ 충분하다\n\n이 코드와 구조를 기준으로 다음을 설명할 수 있다면:\n\n데이터 흐름 (state → derive → render)\n\n검색/필터가 어디서 처리되는지\n\n왜 render를 분리했는지\n\n이벤트 위임을 쓴 이유\n\n에러가 나면 어디부터 의심할지\n\n👉 신입 코딩테스트 / 과제 기준으로 충분한 수준이다.\n\n12. 지금 단계에서 더 깊이 들어갈 필요가 없는 이유\n\nDOM API 내부 구현\n\nattribute vs property 차이\n\n성능 최적화\n\n라이브러리 내부 동작\n\n이건 시니어 영역이고,\n지금 파면 오히려 혼란만 커진다.","date":"2026-01-06T07:48:27.681Z"},{"id":1767687686121,"category":"coding","title":"코딩적사고와 crud + search + filter기준에서 쓰이는 일본어들","content":"1️⃣ 코딩 사고는 한국어보다 일본어가 유리한가?\n\n조건부로 YES라고 말할 수 있어. 이유는 “언어가 사고를 끌어가는 방향” 차이 때문이야.\n\n🔹 한국어의 특징 (코딩 사고에 불리한 지점)\n\n맥락 의존이 큼\n\n주어/목적어 생략이 잦음\n\n감정·뉘앙스 중심 표현이 많음\n\n예:\n\n“이거 여기서 처리하면 되지 않을까?”\n\n→ 사고가 흐릿해짐\n→ 구현 전에 감정·추측이 먼저 개입\n\n🔹 일본어의 특징 (코딩 사고에 유리한 지점)\n\n행위 중심(동사 중심)\n\n절차/단계 표현이 강함\n\n“무엇을 한다”가 항상 드러남\n\n예:\n\n状態を更新する\n条件を判定する\n表示を切り替える\n\n→ 사고가 절차 단위로 쪼개짐\n→ 코드 구조와 거의 1:1 대응\n\n📌 그래서 일본 개발자 코드/설명은\n“감정 없음 + 처리 흐름 설명” 느낌이 강함.\n\n🔹 결론\n\n일상 사고 → 한국어가 편함\n\n구조·절차·로직 사고 → 일본어가 오히려 정돈됨\n\n그래서 코딩 사고만 놓고 보면 일본어가 유리한 면이 있다고 말할 수 있어.\n\n2️⃣ 지금 수준(CRUD + search/filter)에서 반드시 접하는 일본어\n\n아래는 지금 네가 쓰는 코드 사고와 거의 1:1 대응되는 일본어만 정리했어.\n(외우는 용도 ❌ / 자주 보면서 익숙해지는 용도 ⭕)\n\n📌 상태 / 데이터 관련\n일본어\t의미\t코딩 사고\n状態（じょうたい）\t상태\tstate\nデータ\t데이터\tdata\n配列（はいれつ）\t배열\tarray\n要素（ようそ）\t요소\telement\n一覧（いちらん）\t목록\tlist\n管理する\t관리하다\tmanage\n📌 CRUD 기본 동사 (핵심)\n일본어\t의미\tCRUD\n追加する\t추가하다\tCreate\n取得する\t가져오다\tRead\n更新する\t갱신하다\tUpdate\n削除する\t삭제하다\tDelete\n\n👉 일본 개발자 사고는 거의 이 4개 동사로 시작함.\n\n📌 검색 / 필터 / 조건\n일본어\t의미\t사용 맥락\n検索する（けんさく）\t검색하다\tsearch\n条件（じょうけん）\t조건\tfilter\n判定する\t판단하다\tif 조건\n絞り込む\t추려내다\tfilter\n含む\t포함하다\tincludes\n📌 처리 흐름 / 로직\n일본어\t의미\t코딩 사고\n処理する\t처리하다\tprocess\n実行する\t실행하다\texecute\n呼び出す\t호출하다\tcall\n分岐する\t분기하다\tbranching\n繰り返す\t반복하다\tloop\n📌 화면 / 렌더링 / DOM\n일본어\t의미\t대응 개념\n表示する\t표시하다\trender\n再描画する\t다시 그리다\tre-render\n画面\t화면\tUI\n要素を取得する\t요소를 가져오다\tquerySelector\n追加する\t추가하다\tappend\n📌 이벤트 / 사용자 조작\n일본어\t의미\nイベント\t이벤트\n入力\t입력\n送信\t제출\n変更\t변경\nクリック\t클릭\n📌 에러 / 디버깅 (중요)\n일본어\t의미\nエラー\t에러\n原因\t원인\n発生する\t발생하다\n存在しない\t존재하지 않다\nnull\tnull\n未定義\tundefined\n\n예문 하나만 기억해도 충분:\n\nDOM要素が存在しない状態で\nイベントを登録しようとしたため、エラーが発生した。\n\n3️⃣ 추천 사고 전환 방식 (지금 단계 최적)\n\n❌ “일본어로 생각해야지”\n⭕ “코딩 동사를 일본어로 붙인다”\n\n예:\n\n“여기서 render 해야겠다”\n→ 表示を更新する\n\n“이건 상태 변경이네”\n→ 状態を更新する\n\n“조건으로 걸러야지”\n→ 条件で絞り込む\n\n이렇게 행동 단위로 일본어를 붙이면\n어느 순간 한국어를 안 거치게 된다.\n\n마지막 한 문장 정리\n\n코딩 사고는 감정 언어가 아니라\n절차 언어라서,\n일본어와 구조적으로 잘 맞는다.\n\n지금 네 수준에서 필요한 일본어는\n이미 충분히 정리 가능한 범위고,\n지금처럼 쓰다 보면 자연스럽게 일본어로 코딩 사고가 열린다.","date":"2026-01-06T08:21:26.121Z"},{"id":1767779014077,"category":"japanese","title":"「分ける（わける）」","content":"「分ける（わける）」は、一つを複数に分割する（ケーキを分ける）、種類ごとに整理する（ゴミを分別する）、配る・分配する（お菓子を分ける）、（物理的に）押し開く（カーテンを分ける）、勝負を区切る（引き分けにする）など、状況によって様々な意味を持つ動詞で、英語では「divide」「separate」「share」「split」などを使い分けます。 \n主な意味と例文\n分割・分割する: 一つを二つ以上に分ける。\n例: ケーキを4つに分ける (divide the cake into four pieces)。\n区分する・分類する: 種類や性質で分ける。\n例: リサイクルとゴミを分ける (separate recycling from trash)。\n分配する・分け与える: 複数人に配る。\n例: 財産を息子たちに分ける (share the property with his sons)。\n（物理的に）押し開く: 物理的に物を左右に開く。\n例: 髪を真ん中で分ける (part her hair in the middle)。\n（勝負・仲裁で）区切る: 勝負がつかないときにやめさせる、引き分けにする。\n例: 勝負を分ける（引き分けにする）。 \n関連する言葉\n分割: divide, split\n分別: separate\n分配: share, distribute\n区切る: cut, break\n\nhttps://mazii.net/ko-KR/search/word/jako/%E5%88%86%E3%81%91%E3%82%8B\n\n◆ 나누다.\n◆ 가르다.\n\n数区域に分ける\n몇 구역으로 나누다\n\n株を分けて植える\n포기[그루]를 나눠서 심다\n\n五回に分けて支払う\n다섯 번에 나누어 지급하다\n\n◆ (종류에 따라) 구분[분류]하다.\n\n学年別に分ける\n학년별로 나누다\n\n大きさによって分ける\n크기에 따라서 분류하다\n\n成績を五段階に分ける\n성적을 5단계로 구분하다\n\n◆ ((頒ける)) 분배하다; 노느다.\n\n利益を分ける\n이익을 나누다\n\n皆で分けて食べる\n모두가 나누어 먹다\n\n暖簾を分ける\n분점을 차려 주다(같은 옥호를 쓰게 하며 단골집도 일부 나누어 줌)\n\n◆ 말리다; 중재하다.\n\n喧嘩を分ける\n싸움을 말리다\n\n◆ 비긴 것으로 하다.\n\n勝負を分ける\n승부를 무승부로 하다\n\n星を分ける\n승패의 결과가 무승부가 되다\n\n票を分ける\n득표수가 같이 되다\n\n◆ 헤치다.\n\n波を分けて船が進む\n파도를 헤치고 배가 나아가다\n\n草の根を分\n(풀뿌리를 헤치듯) 샅샅이 뒤지다\n\n人込みの中を分けて前に出る\n군중 속을 헤치고 앞으로 나오다\n\n◆ 조리 있게 하다; 시비를 가리다; 판별하다.\n\n事を分けて話した\n조리 있게 차근차근 이야기했다\n\n◆ 팔다.\n\nお分けいたしましょう\n팔도록 하겠습니다\n\n分けて下さいませんか\n파시지 않겠습니까","date":"2026-01-07T09:43:34.077Z"},{"id":1767779208105,"category":"japanese","title":"配る（くばる）と分ける（わける）のちがさ","content":"https://blog.naver.com/maisensei-japanese/222485880966\n\n配（くば）る\n\n１ 物を、適当な量に分けて、それぞれに行き渡るようにする。割り当てて渡す。\n\n물건을 적당한 양으로 나누어 각각에 골고루 전달하도록 한다.할당해서 넘기다.\n\n​\n\n「カードを配る／카드 나눠주다」\n\n​\n\n２ 方々に届けて回る。配達する。\n\n사방에 물건을 전달하고 다니다.배달하다.\n\n「新聞を配る/ 신문을 배달한다.」\n\n​\n\n３ 配慮や注意などを行き渡らせる。方々に行き届かせる。\n\n배려나 주의등을 골고루 준다.사방에 두루 미치다.\n\n「気を配る/매려하다 주의하가」\n\n分ける\n\n１ 一つにまとまっているものをいくつかの部分にする。分割する。\n\n하나로 뭉쳐 있는 것을 몇 개의 부분으로 만든다.분할한다.\n\n「ケーキを分ける／케이크를 나누다」 \n\n​\n\n​\n\n２ 種類によって区分する。分類する。\n\n종류에 따라 구분한다.분류하다.\n\n「子供と大人に分ける／아이와 어른으로 나누다」\n\n「大きさによって分ける／크기에 따라 나누다」\n\n​\n\n３ 幾つかに割って与える。分配する。また、一部分を人に与える。\n\n여러 개로 쪼개서 주다.분배하다.또 한 부분을 남에게 준다.\n\n「財産を三人の息子に分ける／재산을 세 아들에게 나누어 준다」\n\n「いただき物をお隣に分ける／먹거리를 이웃에게 나누어 준다」\n\n​\n\n☞おすそ分けするとも言いますね。\n\n사전에서도 알 수 있듯이\n\n「配る」　\n\n적당한 양을 각자에게 골고루 준다\n\n​\n\n「分ける」　\n\n하나의 것을, 혹은 많이 모여서 하나가 된 것을 \n\n여러 그룹으로 분할한다\n\nとなりますね","date":"2026-01-07T09:46:48.105Z"},{"id":1768038487004,"category":"coding","title":"const / let 때문에 CRUD에서 터지는 이유 정리 (실전 기록용)","content":"✅ const / let 때문에 CRUD에서 터지는 이유 정리 (실전 기록용)\n1) 문제 상황 요약\n\n전역에 아래처럼 선언했다:\n\nconst items = [];\n\n\n그리고 CRUD 기능을 만들던 중:\n\nedit()는 정상 동작\n\ndelete()는 실행 시 에러 발생\n\n에러 메시지:\n\nUncaught TypeError: Assignment to constant variable.\n\n2) 에러 메시지 뜻 (결론)\n\nAssignment to constant variable의 의미는 단 하나임.\n\nconst로 선언한 변수에 “재할당(reassign)”을 시도했을 때 발생하는 에러\n\n즉, 아래 같은 코드가 실행되었다는 뜻이다:\n\nitems = something; // ❌ const 변수에 재할당 → 에러\n\n3) 왜 edit에서는 const가 문제 없었나?\n\nedit()에서 사용한 형태는 보통 이런 구조였다:\n\nconst it = items.find((x) => x.id === id);\n\n\n✅ 이 코드는 items에 재할당하는 게 아니라\n\nitems에서 데이터를 찾아서\n\n그 결과를 it라는 새 변수에 저장하는 것\n\n즉,\n\nconst items는 그대로 유지\n\nconst it는 edit 함수 안에서만 쓰는 “지역 변수”라 OK\n\n📌 핵심:\n\nconst it = ... 는 새 변수를 만드는 것이라 문제 없음.\n\n4) 왜 delete에서는 터졌나? (진짜 원인)\n\ndelete 함수에서는 이런 패턴이 들어갔을 가능성이 높다:\n\nitems = items.filter((x) => x.id !== id);\n\n\n이 코드의 의미는:\n\nfilter()는 기존 배열을 수정하지 않고,\n\n새 배열을 만들어서 반환\n\n그 새 배열을 items에 다시 넣으려 함 (재할당)\n\n그런데 items가 const였기 때문에\n\n❌ 재할당 불가능 → 에러 발생\n\n📌 핵심:\n\nitems = ... 같은 재할당 코드가 들어가면\nitems는 let이어야 함.\n\n5) const는 언제 문제이고, 언제 문제 아닌가?\n✅ const로 선언해도 가능한 것 (내용 수정)\nconst items = [];\n\nitems.push(newItem);         // ✅ 가능\nitems.splice(index, 1);      // ✅ 가능\nitems[index].title = \"A\";    // ✅ 가능\nitems.length = 0;            // ✅ 가능\n\n❌ const로 선언하면 불가능한 것 (재할당)\nconst items = [];\n\nitems = [];                  // ❌ 불가능\nitems = items.filter(...);   // ❌ 불가능\nitems = items.map(...);      // ❌ 불가능\n\n\n📌 정리:\n\nconst는 “내용 변경 가능”\n대신 “변수 자체를 다른 값으로 갈아끼우기(재할당)”는 불가능\n\n6) 해결 방법 정리\n✅ 해결 방법 A) 재할당을 할 거면 let 사용 (가장 간단/명확)\nlet items = [];\n\nfunction deleteItem(id) {\n  items = items.filter((x) => x.id !== id); // ✅ OK\n}\n\n✅ 해결 방법 B) const 유지 + 배열 내부만 수정하는 방식\nconst items = [];\n\nfunction deleteItem(id) {\n  const index = items.findIndex((x) => x.id === id);\n  if (index !== -1) items.splice(index, 1); // ✅ OK\n}\n\n7) 실전 CRUD 패턴 정리 (외워두면 좋음)\n✅ Create\nitems.push(newItem); // const여도 가능\n\n✅ Read\nconst it = items.find(...); // 읽기라서 const 사용 OK\n\n✅ Update (2가지 방식)\nA) 재할당 방식 (let 필요)\nitems = items.map(...);\n\nB) 내부 변경 방식 (const 유지 가능)\nconst it = items.find(...);\nit.title = \"new\";\n\n✅ Delete (2가지 방식)\nA) 재할당 방식 (let 필요)\nitems = items.filter(...);\n\nB) 내부 삭제 방식 (const 유지 가능)\nitems.splice(index, 1);\n\n✅ 최종 한 줄 결론\n\nedit는 “새 const 변수를 선언해서 사용”했기 때문에 괜찮았고\ndelete는 “const items에 재할당”했기 때문에 에러가 난 것이다.","date":"2026-01-10T09:48:07.004Z"},{"id":1768039237302,"category":"coding","title":"edit vs delete 구조 차이 정리","content":"✅ edit vs delete 구조 차이 정리 (기록용)\n1) edit 함수 흐름 (find + early return)\n\nedit는 보통 이런 구조가 맞다:\n\nconst it = items.find(x => x.id === id);\nif (!it) return;\n\n✅ 이유\n\nedit는 “어떤 항목을 수정할지”가 명확해야 함\n\nid로 해당 항목 1개를 찾아야 함 (find)\n\n없으면 더 진행하면 안 되므로 조기 종료(early return) 하는 게 정석\n\n📌 즉 edit는\n\n대상 선택(find) → 검증(if(!it)return) → 수정 로직 실행\n\n이 순서가 매우 자연스럽고 실무에서도 자주 쓰임.\n\n2) delete 함수 흐름 (filter로 재할당)\n\ndelete는 보통 이런 스타일로 짧게 가능:\n\nitems = items.filter(x => x.id !== id);\nrender();\n\n✅ 이유\n\ndelete는 “해당 id를 제외한 새 배열”이 필요함\n\n그 역할이 filter\n\n따라서 결과를 items에 재할당하는 패턴이 가장 흔함\n\n📌 즉 delete는\n\n배열 재구성(filter) → 재할당 → 다시 렌더링\n\n이라서 짧아지는 게 정상임.\n\n※ 다만 이 방식은 items가 const이면 재할당 불가능 → let items가 필요.\n\n3) edit가 길어지고 delete가 짧아지는 이유 (핵심)\n\n너가 말한 게 진짜 정확함.\n\n✅ edit가 길어지는 이유\n\nedit는 단순히 데이터만 바꾸는 게 아니라, 사용자와 상호작용 흐름이 있음.\n\n너 edit는 이런 UX를 포함하고 있음:\n\nprompt 창 열기\n\n기존 텍스트 찾아서 prompt 기본값으로 뿌리기\n\n사용자가 수정한 값을 입력\n\n변경된 텍스트를 화면에 다시 렌더링\n(필요하면 localStorage도 갱신)\n\n즉 edit는\n\n“UI 상호작용” + “데이터 수정”\n두 축이 같이 들어가서 코드가 길어질 수밖에 없음.\n\n✅ delete가 짧은 이유\n\ndelete는 UX적으로 사용자가 입력할 게 없음.\n\n클릭\n\n데이터에서 제거\n\n렌더링\n\n이게 끝이라서\n\n데이터 조작만 하고 끝나는 단순 흐름 = 코드가 짧아짐\n\n4) 너 표현 중 정확한 포인트 하나 보강\n\n너가 “delete는 items를 재할당하고 filter 걸고 바로 리턴하는 방식”이라고 했는데\n여기서 엄밀히 말하면:\n\nfilter 자체가 “return(반환)”을 함 (새 배열)\n\n그 반환 값을 items에 재할당하는 구조\n\n즉 “delete 함수가 리턴한다” 보단:\n\nfilter가 새 배열을 반환하고 → 그걸 items가 받아서 대체한다\n\n이 흐름이 더 정확해.\n\n✅ 최종 결론 한 줄\n\nedit는 특정 대상을 찾아(find) 검증하고(early return) 사용자 입력(prompt)까지 받기 때문에 길어지는 게 정상\n\ndelete는 filter로 배열을 재구성해서 다시 렌더링만 하면 되므로 짧은 게 정상\n\n이 정도로 이해했으면 이제 거의 “CRUD 설계 감각”이 생긴 상태야","date":"2026-01-10T10:00:37.302Z"},{"id":1768039966786,"category":"coding","title":"class,id,data-act구분","content":"✅ 1) “할 수 있는데 안 하는 이유는 다 있다” → 이게 핵심\n\n맞아. 규칙은 다 이유가 있어.\n\nclass로도 기능 구현 가능 ✅\n\n그런데 안 하는 이유 = 혼선 방지 + 유지보수성\n\n실무에서 제일 무서운 건 기능 구현보다\n나중에 수정하다가 기능이 깨지는 것이거든.\n\n✅ 2) 네가 정리한 규칙은 완벽하게 맞음\n\n너가 말한 걸 “정석 규칙”으로 한 줄씩 딱 정리하면:\n\n정적 DOM(이미 HTML에 있는 요소)\n→ id로 잡아서 기능 부여가 편하고 명확하다.\n\n동적 DOM(반복 생성되는 요소 / 리스트 아이템)\n→ id는 중복되므로 부적합\n→ data-*로 “대상(id)”과 “행동(act)”을 표시하는 게 좋다.\n\nclass는 기능용으로도 가능하지만\n→ 디자인/스타일링(Tailwind 등)과 섞여서 혼선 가능성 ↑\n→ 그래서 기능 분리는 data-* 추천\n\n✅ 3) “data-*로 표시해서 알려주는 이유” = 맞다\n\n이게 진짜 중요한 문장인데:\n\n이 요소가 “무슨 역할/의도”를 갖고 있는지 개발자끼리 공유하는 표식이다.\n\n즉, HTML이 단순히 UI가 아니라\n**JS랑 연결되는 인터페이스(API처럼)**가 되는 거야.\n\n✅ 4) data-act의 act 부분은 개발자가 정하는 이름이 맞다\n\n정확함.\n\n예를 들어:\n\n<button data-act=\"edit\">Edit</button>\n<button data-act=\"delete\">Delete</button>\n\n\n여기서\n\ndata-act라는 속성명 자체는 HTML 표준 규칙임 (data-* 형태만 맞으면 됨)\n\nact는 개발자가 만든 이름임\n(action의 약자처럼 쓰는 관습)\n\n그래서 이런 것도 전부 가능해\n<button data-action=\"edit\">\n<button data-role=\"edit\">\n<button data-type=\"edit\">\n<button data-kind=\"edit\">\n\n\n즉,\n\ndata-xxx에서 xxx는 개발자 마음대로.\n\n그중에서 act는 관습적으로\n**“이 버튼이 수행할 행동(action)”**을 의미하게끔 정한 거고.\n\n✅ 5) 실무에서 자주 쓰는 data-* 네이밍 관습\n행동 표시\n\ndata-act\n\ndata-action\n\ndata-handler\n\n대상 표시\n\ndata-id\n\ndata-item-id\n\ndata-entry-id\n\n예:\n\n<button data-act=\"edit\" data-id=\"17\">\n\n\n이건 해석이 너무 쉬워짐:\n\nid가 17인 데이터를 edit해라\n\n✅ 최종 결론 (너가 딱 이해한 그대로)\n\n✅ 규칙을 정한 이유는 “혼선 방지”\n✅ class는 디자인과 섞여서 혼선 생길 수 있음\n✅ id는 정적인 요소에 적합\n✅ 동적 생성 요소는 data-*가 적합\n✅ data-act의 act는 개발자가 정한 이름(관습적으로 action 의미)","date":"2026-01-10T10:12:46.786Z"},{"id":1768042090370,"category":"coding","title":"일본스타트업 선택시 유의사항 ex)정시퇴근 개인사업","content":"1) 왜 정시퇴근 보장이 프리 전향에 필수인가?\n\n프리는 실력도 필요하지만, 그 전에\n\n시간\n\n체력\n\n에너지\n\n이게 없으면 절대 못 함.\n\n회사 일이 매일 9~10시까지 잡아먹으면:\n\n사이드 프로젝트도 못 하고\n\n외주도 못 하고\n\n공부도 못 하고\n\n결국 노마드 플랜이 “영원히 계획”으로만 남아.\n\n그래서 네가 말한 건 진짜 핵심이야:\n\n프리로 가려면 회사에 묶이면 안 된다.\n\n2) 근데 면접에서 “정시퇴근 보장되나요?” 이렇게 물으면 위험할 수 있음\n\n여기서 한 가지 전략이 필요해.\n\n회사 입장에서 저 질문을 들으면 이렇게 해석할 수도 있어:\n\n“이 사람은 워라밸만 따지는 사람인가?”\n\n“스타트업에 안 맞는 타입인가?”\n\n“필요할 때 야근 못 하겠다는 뜻인가?”\n\n그래서 물어야 하긴 하는데, 물어보는 방식이 중요해.\n\n3) “안 뽑을 수도 있다”는 건 오히려 좋은 신호일 수도 있음\n\n냉정하게 말하면:\n\n✅ 너의 목표: “정시퇴근 기반으로 프리/노마드 준비”\n❌ 어떤 회사의 목표: “회사에 올인할 사람”\n\n이건 가치관 충돌이라\n서로 안 맞는 게 맞아.\n\n그럼 차라리 초반에 걸러지는 게 장기적으로는 이득임.\n\n4) 현실적인 최적 질문 방식 (안 튀면서 확인하기)\n\n정시퇴근을 대놓고 “보장”으로 묻기보다는\n업무 운영 방식을 묻는 게 실무에서 가장 자연스러워.\n\n예를 들어:\n\n✅ 질문 1) 평균 야근 빈도\n\n“通常時の残業頻度はどれくらいでしょうか？”\n(평소 야근 빈도는 어느 정도인가요?)\n\n✅ 질문 2) 야근이 생기는 시점\n\n“残業が発生するのは、どのようなタイミングが多いですか？”\n(야근이 발생하는 타이밍은 주로 언제인가요?)\n\n✅ 질문 3) 근무시간 문화\n\n“勤務時間の考え方として、成果重視でしょうか、時間重視でしょうか？”\n(근무시간은 성과 중심인가요, 시간 중심인가요?)\n\n✅ 질문 4) 리모트/유연근무\n\n“リモートワークやフレックスの運用状況を教えてください。”\n(재택/플렉스 운영 상황을 알려주세요.)\n\n이렇게 물으면\n\n“워라밸충” 느낌이 아니라\n\n진짜 실무 궁금증처럼 들리고\n\n회사도 솔직하게 말할 확률이 높아.\n\n5) 너의 결론을 더 강하게 만들어주는 한 문장\n\n너가 원하는 회사는 결국 이거야:\n\n“일은 빡세도 좋지만,\n시간을 뺏기진 않는 회사”\n\n스타트업 중에도 이런 회사는 분명히 존재하고,\n그런 회사만 잡으면 프리/노마드 전환이 진짜 가능해져.","date":"2026-01-10T10:48:10.370Z"},{"id":1768042679344,"category":"coding","title":"일본 중소기업과 스타트업의 “관리되는 야근”인지 “방치되는 야근”인지 구분하는 질문/체크리스트","content":"좋아. 바로 “면접에서 그대로 읽어도 되는 수준”으로 중소기업 버전 / 스타트업 버전 두 세트 만들어줄게.\n(너 목적: 정시퇴근 기반 + 장기적으로 프리/노마드 준비를 깔끔하게 확인)\n\n핵심 차이는 이거야:\n\n중소기업: 분위기/예의/조직문화 중요 → 부드럽고 신중하게 묻기\n\n스타트업: 실전/속도/현실 중요 → 구체적으로, 숫자로, 시스템으로 묻기\n\n✅ 1) 중소기업 버전 (부드럽고 안정지향 질문 세트)\n시작 멘트 (정중/안정형)\n\n長く安定して働きたいと考えておりますので、働き方についていくつか確認させてください。\n(오랫동안 안정적으로 일하고 싶어서 근무 방식에 대해 몇 가지 확인드리고 싶습니다.)\n\nA. 잔업(야근) 평균/문화 확인\nQ1) 월 평균 잔업\n\n月平均の残業時間はどれくらいでしょうか？\n(월 평균 야근 시간은 어느 정도인가요?)\n\nQ2) 정시퇴근 분위기\n\n定時で退勤される方も多いでしょうか？\n(정시에 퇴근하시는 분들도 많은 편인가요?)\n\n✅ 중소기업에선 “많습니다/적당히 있습니다” 같은 답이 나오면 정상.\n\nB. 야근 발생 원인(업무량/시기) 확인\nQ3) 야근이 생기는 타이밍\n\n残業が発生するのは、どのような時期が多いでしょうか？\n(야근이 발생하는 시기는 주로 언제인가요?)\n\nQ4) 업무 일정 운영 스타일\n\n業務スケジュールはどのように管理されていますか？\n(업무 일정은 어떤 식으로 관리되나요?)\n\nC. 보상/규정 확인 (중요하지만 부드럽게)\nQ5) 잔업수당/대체휴무\n\n残業代の支給や代休制度について教えていただけますか？\n(야근 수당 지급이나 대체휴무 제도에 대해 알려주실 수 있을까요?)\n\nQ6) “みなし残業(포괄임금)” 여부\n\n固定残業（みなし残業）の制度はありますか？\n(포괄임금(고정 잔업) 제도가 있나요?)\n\nD. 유연근무/재택(가능하면)\nQ7) 재택/플렉스 운영\n\nリモートワークやフレックス制度の運用状況を教えてください。\n(재택근무나 플렉스 운영 상황을 알려주세요.)\n\n마무리 멘트 (호감형)\n\n無理なく長期的に成果を出したいと思っておりますので、確認させていただきました。ありがとうございます。\n(무리 없이 장기적으로 성과를 내고 싶어서 확인드렸습니다. 감사합니다.)\n\n✅ 2) 스타트업 버전 (실전형/구체적/숫자 중심)\n시작 멘트 (스타트업스럽게)\n\nパフォーマンスを安定して出すために、開発体制と働き方を具体的に確認させてください。\n(안정적으로 성과를 내기 위해 개발 체계와 근무 방식을 구체적으로 확인드리고 싶습니다.)\n\nA. 근무시간/야근을 “숫자”로 뽑아내는 질문\nQ1) 팀의 월 평균 잔업 (필수)\n\n配属予定チームの月平均残業時間はどれくらいですか？\n(배치 예정 팀의 월 평균 야근 시간은 어느 정도인가요?)\n\nQ2) 최근 3개월 기준으로 묻기 (회피 불가)\n\n直近3ヶ月だと、残業はどれくらいの水準でしたか？\n(최근 3개월 기준으로는 야근이 어느 수준이었나요?)\n\n✅ 스타트업에서는 “최근 수치”를 물어야 진짜가 나옴.\n\nB. “야근이 왜 발생하는가” (회사 운영 수준 파악)\nQ3) 야근 발생 원인 TOP3\n\n残業の主な原因は何でしょうか？（例：リリース前、仕様変更、障害対応など）\n(야근의 주된 원인은 무엇인가요? 예: 릴리즈 전, 요구사항 변경, 장애 대응 등)\n\nQ4) 일정이 터질 때 대응 방식\n\nスケジュールが厳しい場合、スコープ調整は行われますか？\n(일정이 빡빡할 때 스코프 조정은 하나요?)\n\n✅ 좋은 스타트업 = 스코프 컷/우선순위 조정 있음\n⚠️ 위험 = “다 같이 밤새워요”\n\nC. 인원 부족 여부 확인 (너가 제일 중요하게 보는 지점)\nQ5) 개발 인력 충원 상황\n\n現状、開発人数は足りていますか？採用計画はどうなっていますか？\n(현재 개발 인원은 충분한가요? 채용 계획은 어떻게 되나요?)\n\nQ6) 한 사람이 맡는 범위\n\nエンジニア1人あたりの担当範囲は広いですか？（フロント・バック・インフラ等）\n(엔지니어 1인당 담당 범위가 넓은 편인가요? 프론트/백/인프라 등)\n\nD. 야근이 “관리되는가” 판별 질문\nQ7) 야근 상한/관리 방법\n\n残業時間の上限管理はどうされていますか？\n(야근 시간 상한 관리는 어떻게 하나요?)\n\nQ8) 온콜/장애 대응\n\nオンコールはありますか？頻度とローテーション体制を教えてください。\n(온콜이 있나요? 빈도와 로테이션 체계를 알려주세요.)\n\nE. 재택/플렉스 “진짜로 쓰는지” 확인\nQ9) 재택/플렉스 실운영\n\nリモート／フレックスは制度としてありますか？実際の利用率はどれくらいですか？\n(재택/플렉스가 제도로 있나요? 실제 사용률은 어느 정도인가요?)\n\nF. 보상/정산 (블랙 여부 확인)\nQ10) 수당/대휴\n\n残業代は全額支給ですか？代休も取れますか？\n(야근 수당은 전액 지급인가요? 대체휴무도 쓸 수 있나요?)\n\nQ11) “みなし残業”이면 몇 시간인지\n\nみなし残業の場合、何時間分が含まれていますか？\n(포괄임금이면 몇 시간분이 포함되어 있나요?)\n\n마무리 멘트 (프로형)\n\n長期的にパフォーマンスを維持したいので、運用面まで具体的に確認しました。\n(장기적으로 퍼포먼스를 유지하고 싶어서 운영 측면까지 구체적으로 확인했습니다.)\n\n✅ “답변”으로 판별하는 빠른 기준\n🟢 감당 가능한 야근 확률 높음\n\n팀 평균 잔업이 10~20h\n\n“릴리즈 전 1~2주” 같은 명확한 패턴\n\n“우선순위/스코프 조정”이 가능\n\n수당/대휴 규정 명확\n\n재택/플렉스 실사용\n\n🔴 감당 불가 확률 높음 (피하는 게 좋음)\n\n“사람마다 달라요”만 반복\n\n“많긴 한데 어쩔 수 없죠”\n\n“열정/각오” 같은 감성으로 덮음\n\n온콜이 사실상 상시\n\n“제도는 있는데 쓰는 사람 없음”","date":"2026-01-10T10:57:59.344Z"}]